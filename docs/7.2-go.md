# Go Bluesky MCP Server

Model Context Protocol server for Bluesky profile and post search functionality implemented in Go.

## Overview

Implements two MCP tools:
- `profile(account)` - Retrieve user profile information
- `search(account, query)` - Search posts within a user's repository

This Go implementation provides feature parity with the Rust version while leveraging Go's strengths in single-binary deployment, mature CAR tooling, and straightforward concurrency patterns.

## API Specification

### Tool: profile

**Parameters:**
```json
{
  "account": "string"  // Handle (alice.bsky.social) or DID (did:plc:...)
}
```

**Returns:** Markdown-formatted profile information

### Tool: search

**Parameters:**
```json
{
  "account": "string", // Handle or DID
  "query": "string"    // Search terms (case-insensitive)
}
```

**Returns:** Markdown-formatted list of matching posts

### Input Validation

- **account**: Must be valid handle format `name.host.tld` or DID format `did:plc:[a-z2-7]{24}`
- **query**: Plain text, normalized via Unicode NFKC, trimmed whitespace
- Maximum query length: 500 characters

### MCP Protocol Format

**Request:**
```json
{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "profile", "arguments": {"account": "alice.bsky.social"}}}
```

**Success Response:**
```json
{"jsonrpc": "2.0", "id": 1, "result": {"content": [{"type": "text", "text": "# Profile\n\n..."}]}}
```

**Error Response:**
```json
{"jsonrpc": "2.0", "id": 1, "error": {"code": "did_resolve_failed", "message": "Unable to resolve handle to DID"}}
```

## Technical Implementation

### Core Components

#### 1. DID Resolution Module

**Handle Resolution:**
- Resolve via XRPC using Go's standard `net/http` client
- Endpoint: `https://{hostname}/xrpc/com.atproto.identity.resolveHandle?handle={handle}`
- HTTP client configuration with connection pooling and appropriate timeouts
- Implement retry logic with exponential backoff for transient failures

**DID Validation:**
- Use regex pattern matching for DID format validation
- Support both full DID and shortened DID formats
- Handle case normalization consistently

**PDS discovery:**
- The CAR archive for a repository is served by the user's Personal Data Server (PDS). Resolving a handle or DID must include discovering the PDS endpoint and using that host as the source for CAR downloads (not a generic bsky.social host). Below is a concise example of how a DID can be translated into a PDS endpoint by inspecting the PLC audit log (example pseudo-code):

```js
const plcLog = JSON.parse(await fetchRetryText(`https://plc.directory/${did}/log/audit`));
const pds = plcLog
    .slice()
    .reverse()
    .map(entry => entry.operation?.services?.atproto_pds?.endpoint)
    .find(Boolean);
// Use `pds` (if present) as the base URL for CAR downloads, e.g.
// `${pds}/xrpc/com.atproto.sync.getRepo?did=${did}`
```

#### 2. CAR Cache System

**Cache Directory Structure:**

Two-tier subdirectories for scalability using first two letters of DID hash as prefix:

```
{cache_dir}/
├── {2-letter-prefix-of-did-hash}/
│   └── {full-did}/
│       ├── repo.car
│       └── metadata.json
```

**Example:**
For DID `did:plc:abc123xyz789`, calculate hash prefix from the DID string, resulting in path like `{cache_dir}/ab/did:plc:abc123xyz789/`.

**Cache Location Determination:**
- Linux/macOS: Use `$XDG_CACHE_HOME/bluesky-mcp` or fallback to `$HOME/.cache/bluesky-mcp`
- Windows: Use `%LOCALAPPDATA%\bluesky-mcp`  
- Implement via `os.UserCacheDir()` with custom subdirectory

**Cache Management:**
- Store HTTP headers (Last-Modified, ETag, Content-Length) in `metadata.json`
- TTL configuration: 24 hours for repositories, 1 hour for profiles
- Implement cache cleanup routines for expired entries
- File integrity verification using stored Content-Length
- Atomic file operations using temporary files with `.tmp` suffix

#### 3. CAR Processing Pipeline

**Repository Fetch:**
- Primary endpoint: `https://bsky.social/xrpc/com.atproto.sync.getRepo?did={did}`
- Implement streaming download with progress tracking using Go's `io.Copy`
- Concurrent download protection using file locking via `flock` system call
- HTTP client with streaming support and proper timeout configuration
- Resume partial downloads when possible using HTTP Range requests

**CAR File Processing:**
- Use `github.com/ipld/go-car/v2` library for CAR file parsing
- Implement indexed access for efficient random record retrieval
- Parse CBOR-encoded IPLD blocks using `github.com/fxamacker/cbor/v2`
- Extract specific AT Protocol record types from CAR structure

**Record Type Definitions:**
```go
type ProfileRecord struct {
    DisplayName *string `json:"displayName,omitempty"`
    Description *string `json:"description,omitempty"`  
    Avatar      *string `json:"avatar,omitempty"`
    Banner      *string `json:"banner,omitempty"`
    CreatedAt   string  `json:"createdAt"`
}

type PostRecord struct {
    URI       string    `json:"uri"`
    CID       string    `json:"cid"`
    Text      string    `json:"text"`
    CreatedAt string    `json:"createdAt"`
    Embeds    []Embed   `json:"embeds,omitempty"`
    Facets    []Facet   `json:"facets,omitempty"`
}

type Embed struct {
    Type        string      `json:"$type"`
    External    *External   `json:"external,omitempty"`
    Images      []Image     `json:"images,omitempty"`
}

type External struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    URI         string `json:"uri"`
}

type Image struct {
    Alt   string `json:"alt"`
    Image struct {
        Ref string `json:"$link"`
    } `json:"image"`
}
```

**Target Collections:**
- `app.bsky.actor.profile` - Profile information
- `app.bsky.feed.post` - Post content and metadata

#### 4. Search Implementation

**Text Processing:**
- Unicode normalization using `golang.org/x/text/unicode/norm` package
- Case-insensitive matching using `strings.ToLower` with proper Unicode handling
- Implement text highlighting by wrapping matches in `**bold**` markdown

**Search Scope Coverage:**
- Primary post text content
- Image alt-text within embeds  
- External link titles and descriptions
- Quote post text content (when included)
- Reply context text (when available)

**Search Algorithm:**
- Use Go's `strings` package for efficient substring matching
- Implement result ranking based on match frequency and position
- Consider using `golang.org/x/text/search` for more sophisticated matching
- Optional: Implement fuzzy matching for better user experience

#### 5. HTTP Server and MCP Protocol

**Server Implementation:**
- Use Go's standard `net/http` package for HTTP server
- Implement stdio mode using `os.Stdin` and `os.Stdout` for JSON-RPC communication
- Support both HTTP and stdio transport modes via command-line flag
- JSON-RPC 2.0 protocol implementation with proper error handling

**Concurrency Management:**
- Utilize goroutines for concurrent request handling
- Implement request context propagation for timeout management
- Use channels for coordinating background cache cleanup operations
- Worker pool pattern for limiting concurrent CAR downloads

**Middleware Chain:**
- Request logging and metrics collection
- Request timeout enforcement
- Panic recovery with proper error responses
- Optional: Rate limiting for production deployments

### Error Handling

**Error Type System:**
```go
type ErrorCode string

const (
    InvalidInput     ErrorCode = "invalid_input"
    DIDResolveFailed ErrorCode = "did_resolve_failed"
    RepoFetchFailed  ErrorCode = "repo_fetch_failed"
    RepoParseFailed  ErrorCode = "repo_parse_failed"
    NotFound         ErrorCode = "not_found"
    Timeout          ErrorCode = "timeout"
    CacheError       ErrorCode = "cache_error"
)

type McpError struct {
    Code    ErrorCode `json:"code"`
    Message string    `json:"message"`
    Data    any       `json:"data,omitempty"`
}
```

**Timeout Configuration:**
- DID resolution: 10 seconds using `context.WithTimeout`
- CAR download: 60 seconds with progress monitoring
- CAR parsing: 30 seconds for large repositories
- Total request timeout: 120 seconds enforced at handler level

**Error Recovery Strategies:**
- Implement circuit breaker pattern for external service calls
- Graceful degradation when cache operations fail
- Retry logic with exponential backoff for transient network errors
- Detailed error logging for debugging while maintaining user-friendly messages

### Output Formatting

#### Profile Tool Output

Template-based markdown generation:

```markdown
# @{handle} ({did})

**Display Name:** {displayName}

**Description:**
{description}

**Avatar:** ![Avatar]({avatarUrl})

**Stats:**
- Created: {createdAt}
- PDS: {pdsEndpoint}

**Verified Links:**
- {domain}: [Link]({url})

<details>
<summary>Raw Profile Data</summary>

```json
{profileRecord}
```
</details>
```

#### Search Tool Output

Structured search results with highlighting:

```markdown
# Search Results for "{query}" in @{handle}

Found {count} matching posts.

## Post 1
**URI:** [at://{repo}/app.bsky.feed.post/{rkey}]({postUrl})  
**Created:** {timestamp}

{postText with **highlighted** matches}

**Embeds:**
- **External Link:** [{title}]({url})  
  {description}
- **Images:**  
  ![{alt}]({imageUrl})

---

## Post 2
...

**Results:** Showing {shown} of {total} results.
```

## Dependencies

### Required Go Modules

**Core Dependencies:**
- `github.com/ipld/go-car/v2` - CAR file parsing and indexing
- `github.com/fxamacker/cbor/v2` - CBOR encoding/decoding for IPLD
- `golang.org/x/text/unicode/norm` - Unicode normalization
- `golang.org/x/text/transform` - Text transformation utilities
- `golang.org/x/sync/singleflight` - Duplicate request suppression

**Standard Library Usage:**
- `net/http` - HTTP client and server
- `encoding/json` - JSON serialization for MCP protocol
- `context` - Request context and timeout management
- `os` - File system operations and environment variables
- `path/filepath` - Cross-platform file path manipulation
- `regexp` - Pattern matching for validation
- `strings` - String processing and manipulation
- `time` - Timestamp handling and cache TTL

**Optional Dependencies:**
- `github.com/gorilla/mux` - Advanced HTTP routing (if HTTP mode becomes complex)
- `github.com/sirupsen/logrus` - Structured logging (alternative to standard log)
- `github.com/spf13/cobra` - CLI framework (if command-line interface becomes complex)
- `golang.org/x/sys/unix` - File locking primitives for cache coordination

### Dependency Rationale

**CAR Processing:**
Go's `go-car v2` library provides production-ready CAR file handling with indexed access, making it superior to implementing custom CAR parsing. The library includes proper blockstore API and streaming capabilities.

**CBOR Handling:**
`fxamacker/cbor/v2` offers efficient CBOR encoding/decoding with good performance characteristics and proper handling of IPLD data structures.

**Text Processing:**
Go's extended text packages provide robust Unicode normalization and transformation capabilities essential for proper text search functionality.

**HTTP Client:**
Go's standard `net/http` package provides excellent HTTP client capabilities with connection pooling, timeout support, and streaming downloads.

## File Structure

```
cmd/
└── bluesky-mcp/
    └── main.go          // Application entry point

internal/
├── mcp/
│   ├── server.go        // MCP protocol server
│   ├── handler.go       // Request handlers
│   └── types.go         // MCP protocol types
├── bluesky/
│   ├── did.go          // DID resolution
│   ├── car.go          // CAR file operations  
│   ├── records.go      // AT Protocol record types
│   └── client.go       // HTTP client utilities
├── cache/
│   ├── manager.go      // Cache management
│   ├── storage.go      // File system operations
│   └── cleanup.go      // Cache cleanup routines
├── tools/
│   ├── profile.go      // Profile tool implementation
│   ├── search.go       // Search tool implementation
│   └── common.go       // Shared tool utilities
└── config/
    └── config.go       // Configuration management

pkg/
└── errors/
    └── errors.go       // Error types and utilities

go.mod                  // Module definition
go.sum                  // Module checksums
README.md              // Documentation
Dockerfile             // Container build (optional)
```

### File Structure Rationale

**Separation of Concerns:**
- `cmd/` contains the application entry point
- `internal/` contains implementation details not exposed as API
- `pkg/` contains reusable packages that could be imported by other projects

**Modularity:**
Each major component (MCP protocol, Bluesky API, caching, tools) is separated into its own package to enable independent testing and maintenance.

**Standard Go Layout:**
Follows Go community conventions for project structure, making it familiar to Go developers.

## Implementation Checklist

### Phase 1: Core Infrastructure
- [ ] Project setup with Go modules and basic CLI
- [ ] MCP server scaffold with JSON-RPC 2.0 handling
- [ ] DID resolution with handle-to-DID conversion
- [ ] HTTP client configuration with timeouts and retries
- [ ] Basic CAR file download and atomic file operations
- [ ] Cache directory structure with two-tier organization
- [ ] CBOR/IPLD record parsing using go-car v2

### Phase 2: Profile Tool
- [ ] Profile record extraction from CAR files
- [ ] Profile data structure definitions and parsing
- [ ] Markdown template rendering for profile display
- [ ] Error handling and input validation
- [ ] Cache metadata management and TTL enforcement
- [ ] Unit tests for profile processing logic

### Phase 3: Search Tool
- [ ] Post record extraction and indexing
- [ ] Text search implementation with Unicode normalization
- [ ] Search result highlighting with markdown formatting
- [ ] Embed processing (images, links, quotes)
- [ ] Result pagination and ranking
- [ ] Performance optimization for large repositories

### Phase 4: Polish and Production Readiness
- [ ] Comprehensive error handling with proper error codes
- [ ] Cache optimization and background cleanup
- [ ] Logging and monitoring instrumentation  
- [ ] Configuration management (environment variables, config files)
- [ ] Performance testing with realistic data sets
- [ ] Documentation and usage examples
- [ ] Docker container support for easy deployment
- [ ] Graceful shutdown handling for long-running operations

### Phase 5: Advanced Features (Optional)
- [ ] HTTP server mode for non-stdio MCP transport
- [ ] Concurrent request handling and rate limiting
- [ ] Cache warming and prefetch strategies  
- [ ] Metrics collection and health endpoints
- [ ] WASM compilation support using TinyGo
- [ ] Integration tests with real Bluesky data

## Go-Specific Implementation Notes

### Concurrency Patterns

**Goroutine Usage:**
- Background cache cleanup operations
- Concurrent CAR file processing for large repositories
- Request timeout enforcement using context cancellation
- Worker pools for limiting resource usage

**Channel Communication:**
- Progress reporting during large downloads
- Coordination between cache operations
- Graceful shutdown signaling

### Memory Management

**Streaming Processing:**
- Use `io.Copy` for efficient file transfers without loading entire files into memory
- Process CAR blocks incrementally rather than loading entire repository
- Implement backpressure mechanisms for large search result sets

**Resource Cleanup:**
- Proper file handle management with defer statements
- HTTP response body cleanup in all code paths
- Context cancellation for abandoned requests

### Error Handling Patterns

**Error Wrapping:**
Use Go's error wrapping (`fmt.Errorf` with `%w` verb) to maintain error context while providing structured error codes for the MCP protocol.

**Panic Recovery:**
Implement panic recovery middleware to convert unexpected panics into proper MCP error responses.

### Testing Strategy

**Unit Testing:**
- Test each component in isolation using Go's built-in testing package
- Mock external HTTP calls using `httptest` package
- Use table-driven tests for validation logic

**Integration Testing:**
- Test complete request flows with real CAR files
- Cache behavior verification with temporary directories
- Error scenario testing with network failures

### Build and Deployment

**Single Binary:**
Leverage Go's static linking to produce self-contained binaries for easy deployment across different environments.

**Cross Compilation:**
Use Go's cross-compilation capabilities to build for multiple platforms (Linux, macOS, Windows) from a single source.

**Container Support:**
Provide Dockerfile using multi-stage builds to create minimal container images with just the binary and necessary certificates.

This implementation plan provides a comprehensive roadmap for creating a Go-based Bluesky MCP server that matches the functionality of the Rust version while taking advantage of Go's ecosystem strengths and development productivity advantages.