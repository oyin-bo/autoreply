# Authentication Quick Reference

This is a quick-reference companion to the [full implementation plan](./12-auth-implementation-plan.md).

## TL;DR

**Start with:** App password authentication (Phase 1)
**Add later:** OAuth PKCE (Phase 2) and Device Flow (Phase 3)
**Storage:** OS keyring → encrypted file → plaintext (with consent)

## Library Choices

### Rust
```toml
# Phase 1 - App Password
keyring = "2.3"
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
chrono = "0.4"

# Phase 2 - OAuth
atproto-oauth = "0.1"
atproto-client = "0.1"
atproto-identity = "0.1"
```

### Go
```bash
# Phase 1 - App Password
go get github.com/99designs/keyring

# Phase 2 - OAuth
go get github.com/bluesky-social/indigo
# Reference: github.com/haileyok/atproto-oauth-golang (archived)
```

## Authentication Methods

| Method | Use Case | Complexity | Security |
|--------|----------|------------|----------|
| App Password | Initial implementation, simple use cases | Low | Good |
| OAuth PKCE | Interactive desktop apps | Medium | Excellent |
| Device Flow | Headless CLI, CI/CD | Medium | Excellent |

## CLI Commands Design

```bash
# Phase 1
autoreply login --handle alice.bsky.social
autoreply logout --handle alice.bsky.social
autoreply accounts list

# Phase 2
autoreply login --handle alice.bsky.social --oauth
autoreply login --handle alice.bsky.social --device
```

## MCP Tool Design

```json
{
  "name": "login",
  "description": "Authenticate with BlueSky",
  "inputSchema": {
    "type": "object",
    "properties": {
      "handle": { "type": "string" },
      "password": { "type": "string" }
    },
    "required": ["handle", "password"]
  }
}
```

## Implementation Checklist

### Phase 1: Foundation (2 weeks)
- [ ] Credential storage (keyring + file fallback)
- [ ] App password authentication via `createSession`
- [ ] Token refresh logic
- [ ] CLI `login`/`logout` commands
- [ ] MCP `login` tool
- [ ] Multi-account support
- [ ] Tests

### Phase 2: OAuth (2 weeks)
- [ ] OAuth client registration/discovery
- [ ] PKCE implementation
- [ ] DPoP key generation and JWT signing
- [ ] Callback HTTP server
- [ ] Browser launch integration
- [ ] CLI `--oauth` flag
- [ ] Tests

### Phase 3: Production (2 weeks)
- [ ] Device authorization flow
- [ ] Error handling and recovery
- [ ] Logging (without secrets!)
- [ ] Configuration management
- [ ] Documentation
- [ ] Security audit
- [ ] Performance testing

## File Structure

### Rust
```
src/
├── auth/
│   ├── mod.rs              # Public API and types
│   ├── credentials.rs      # Credential struct and JSON
│   ├── storage.rs          # Keyring + file storage
│   ├── app_password.rs     # Phase 1: createSession
│   ├── oauth.rs            # Phase 2: OAuth PKCE
│   ├── device.rs           # Phase 3: Device flow
│   └── callback_server.rs  # OAuth callback handler
├── cli.rs                  # Add login/logout/accounts commands
└── tools/
    └── login.rs            # MCP login tool
```

### Go
```
internal/
├── auth/
│   ├── credentials.go      # Credential types
│   ├── manager.go          # AuthManager
│   ├── storage.go          # Keyring + file storage
│   ├── app_password.go     # Phase 1: createSession
│   ├── oauth.go            # Phase 2: OAuth PKCE
│   ├── device.go           # Phase 3: Device flow
│   └── callback_server.go  # OAuth callback handler
├── cli/
│   ├── login.go            # Login command
│   └── accounts.go         # Account management
└── tools/
    └── login.go            # MCP login tool
```

## Storage Schema

Keyring key: `autoreply-mcp:{handle}`
Value: JSON credential object

```json
{
  "provider": "bsky.social",
  "did": "did:plc:abc123...",
  "auth_method": "app_password",
  "access_token": "eyJ...",
  "refresh_token": "eyJ...",
  "token_expires_at": "2024-01-15T10:30:00Z",
  "dpop_key": null
}
```

## API Endpoints

### App Password
```
POST https://bsky.social/xrpc/com.atproto.server.createSession
{ "identifier": "alice.bsky.social", "password": "..." }

→ { "accessJwt": "...", "refreshJwt": "...", "did": "..." }
```

### Token Refresh
```
POST https://bsky.social/xrpc/com.atproto.server.refreshSession
Authorization: Bearer {refreshJwt}

→ { "accessJwt": "...", "refreshJwt": "..." }
```

### OAuth (Phase 2)
```
# 1. Discover authorization server
GET https://bsky.social/.well-known/oauth-authorization-server

# 2. PAR (optional but recommended)
POST {authz_server}/par

# 3. Authorization
GET {authz_server}/authorize?client_id=...&code_challenge=...

# 4. Token exchange
POST {authz_server}/token
{ "grant_type": "authorization_code", "code": "...", "code_verifier": "..." }
```

## Security Checklist

- [ ] Never log tokens or passwords
- [ ] File storage has mode 0600 (user-only)
- [ ] TLS for all network requests
- [ ] Encrypt file fallback storage
- [ ] Use PKCE even for confidential clients
- [ ] Implement proper state parameter for OAuth
- [ ] Zero sensitive memory when done (Rust: zeroize)
- [ ] Sanitize errors (don't expose tokens in messages)

## Testing Strategy

| Test Type | Coverage |
|-----------|----------|
| Unit | Credential serialization, token expiry, PKCE generation |
| Integration | createSession, refreshSession, keyring storage |
| E2E | Full OAuth flow (mock server), CLI commands, MCP tools |
| Security | No token leaks, proper permissions, encryption works |

## Migration Path

Current JS implementation → Go/Rust Phase 1 → Add OAuth (Phase 2/3)

**No breaking changes:** App passwords continue working indefinitely.

## Decision Log

| Decision | Rationale |
|----------|-----------|
| App password first | Simpler, gets working auth quickly, matches current JS |
| OS keyring primary | Most secure, native platform integration |
| MCP tool for login | Works in all MCP environments, no protocol changes |
| Phased approach | Deliver value incrementally, validate each phase |
| Rust + Go parity | Both implementations should have same features |

## Next Steps

1. Review this plan with stakeholders
2. Get feedback on:
   - Phase priorities
   - OAuth client registration strategy
   - MCP tool vs separate service for OAuth
3. Create Phase 1 implementation tickets
4. Set up development environments
5. Begin implementation

## References

- [Full Implementation Plan](./12-auth-implementation-plan.md)
- [Requirements Wishlist](./11-login.md)
- [Library Ecosystem Review](./7-detour-rust.md)
- [AT Protocol OAuth Spec](https://atproto.com/specs/oauth)
- [RFC 7636 - PKCE](https://datatracker.ietf.org/doc/html/rfc7636)
- [RFC 8628 - Device Flow](https://datatracker.ietf.org/doc/html/rfc8628)
