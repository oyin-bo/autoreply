This document records the analysis and implementation plan to bring the Go server's MCP + CLI login flow into parity with the Rust server.

Summary of current state
- The Rust server implements a unified LoginManager that supports both CLI and MCP flows. It uses the same request/response shapes for both pathways and can return an "elicitation" result when interactive input is required. Elicitation includes a prompt_id, field name, and a human message.
- The Rust MCP layer exposes a `login` tool with a JSON Schema derived from the CLI structs. When required parameters (handle/password) are missing and the request is interactive, the tool returns a ToolResult containing an input prompt (via MCP content item with type `input_text`) and metadata containing prompt_id, field and message.
- The Go server already contains a `LoginTool` in `internal/tools/login.go` and a CLI adapter in `internal/cli/login_adapter.go`. It implements OAuth and app-password flows and returns textual ToolResult messages. However, the Go MCP types (`internal/mcp/types.go`) do not include a `metadata` field on `ContentItem`, and the LoginTool currently returns only simple text items. The CLI adapter has logic to detect an OAuth failure and offer an interactive retry with an app password, but it is not wired to the MCP-style elicitation mechanism used by the Rust server.

Goal
Bring the Go server into parity with the Rust server for the `login` command across MCP and CLI pathways. Concretely this means:
- Support elicitation for missing fields during MCP calls: return an input prompt ContentItem with metadata { prompt_id, field, message } when handle or password is missing and the call is interactive.
- Accept and forward `prompt_id` as an optional opaque field in login parameters so MCP clients can correlate responses.
- Preserve existing CLI behavior: when the user passes `--password` without a value, prompt for a password locally; when interactive and OAuth fails, prompt the user to try app-password and forward that to the MCP tool.

Assumptions
- We will add a small, backward-compatible change to `mcp.ContentItem` by adding an optional `Metadata json.RawMessage` field. MCP consumers that ignore metadata keep working.
- The Go CLI and tools packages can share prompt_id as a string in the arguments map passed to tools.

Contract (inputs / outputs)
- Tool input shape (login): { handle?: string, password?: string, port?: integer, prompt_id?: string }
- Tool output: ToolResult { content: [ ContentItem ] } where ContentItem may be { type: "text", text: string } or { type: "input_text", text: prompt, metadata: { prompt_id, field, message } }

Edge cases to handle
- password key present but empty -> treat as explicit request to use app-password mode and elicit password if interactive
- non-interactive MCP caller -> return an error rather than an elicitation result
- failing to start callback server or exchange tokens -> where interactive, convert to elicitation offering app-password fallback; where non-interactive return an error

Planned code changes (high level)
1) Update MCP types to support metadata on content items
	- File: `go-server/internal/mcp/types.go`
	- Add Metadata field (json.RawMessage or map[string]interface{}) to `ContentItem` and update JSON tags.

2) Extend LoginTool InputSchema and argument handling
	- File: `go-server/internal/tools/login.go`
	- Add `prompt_id` to the InputSchema properties (optional)
	- When `handle` is missing and caller is interactive (we'll detect interactive by presence of a `prompt_id` param OR when running from CLI adapter which will forward a prompt_id), return a ToolResult containing a ContentItem of type `input_text` with metadata { prompt_id, field: "handle", message: "Enter Bluesky handle (e.g., alice.bsky.social)" }
	- When password parameter key is present but empty, and OAuth fails (or in explicit password flow with empty value), return an input_text prompt for `password` similarly.
	- Ensure returned metadata uses a generated prompt_id if none was supplied (16-char random id, like Rust's new_prompt_id)

3) Wire prompt_id through CLI adapter
	- File: `go-server/internal/cli/login_adapter.go`
	- The CLI adapter should handle elicitation responses from the LoginTool by parsing the metadata (which includes prompt_id generated by the tool) and prompting the user locally on the terminal. The CLI does not generate prompt_ids itself; it only forwards prompt_ids when responding to elicitation.

4) Update CLI interactive retry behavior to align with Rust
	- If OAuth fails in interactive CLI mode, return or surface an elicitation with field "password" asking the user for an app password, rather than simply printing an error. The CLI adapter should then prompt locally for a password and re-call the tool with the password param set.

5) Tests & verification
	- Add unit tests verifying ContentItem JSON includes metadata and that `login` tool returns an elicitation ContentItem when handle is missing and prompt_id present.
	- Run `go build` and relevant unit tests.

Step-by-step tasks (implementation plan)
1. (in-progress) Draft this analysis and plan in this document (done)
2. Update `go-server/internal/mcp/types.go` to add Metadata to `ContentItem` (small, backward compatible)
3. Update `go-server/internal/tools/login.go`:
	- Add prompt_id property to InputSchema
	- Detect presence of password key vs absence to decide app-password vs OAuth
	- Return input_text ContentItem with metadata when missing handle/password in interactive mode
	- Generate prompt_id if not provided
4. Update `go-server/internal/cli/login_adapter.go` to forward/generated prompt_id and to prompt/retry flows like Rust
5. Add unit tests covering serialization and elicitation
6. Build and run tests; fix any issues

Notes and rationale
- Using json.RawMessage for metadata keeps the MCP wire format flexible and avoids early coupling to a strict struct. Consumers may parse metadata as needed.
- This is intentionally a small change limited to internal/mcp and internal/tools/login to avoid broad refactors.
- The Rust implementation's elicitation pattern (prompt_id + field + message) is preserved to keep feature parity with clients that depend on that shape.

Next steps I'll take if you'd like me to implement these changes now
- Apply the minimal type change to `internal/mcp/types.go` (add Metadata)
- Implement elicitation logic in `internal/tools/login.go` and add prompt_id to InputSchema
- Update the CLI adapter to forward prompt_id and handle interactive retries
- Run `go build` and unit tests, and report results

Requirements coverage
- Parity for elicitation behavior: Deferred -> this plan defines the changes required.
- Keep CLI interactive behavior intact: Done (plan preserves existing interactive prompting and augments it for parity).
- Backward compatibility for MCP messages: Done (metadata is optional).

If you want, I can implement the changes now. Which pieces would you like me to start with? (I can begin by updating `types.go` and the login tool.)