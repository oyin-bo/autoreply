This document records the analysis and implementation plan to bring the Go server's MCP + CLI login flow into parity with the Rust server.

Summary of current state
- The Rust server implements a unified LoginManager that supports both CLI and MCP flows. It uses the same request/response shapes for both pathways and can return an "elicitation" result when interactive input is required. Elicitation includes a prompt_id, field name, and a human message.
- The Rust MCP layer exposes a `login` tool with a JSON Schema derived from the CLI structs. When required parameters (handle/password) are missing and the request is interactive, the tool returns a ToolResult containing an input prompt (via MCP content item with type `input_text`) and metadata containing prompt_id, field and message.
- The Go server already contains a `LoginTool` in `internal/tools/login.go` and a CLI adapter in `internal/cli/login_adapter.go`. It implements OAuth and app-password flows and returns textual ToolResult messages. However, the Go MCP types (`internal/mcp/types.go`) do not include a `metadata` field on `ContentItem`, and the LoginTool currently returns only simple text items. The CLI adapter has logic to detect an OAuth failure and offer an interactive retry with an app password, but it is not wired to the MCP-style elicitation mechanism used by the Rust server.

Goal
Bring the Go server into parity with the Rust server for the `login` command across MCP and CLI pathways. Concretely this means:
- Support elicitation for missing fields during MCP calls: return an input prompt ContentItem with metadata { prompt_id, field, message } when handle or password is missing and the call is interactive.
- Accept and forward `prompt_id` as an optional opaque field in login parameters so MCP clients can correlate responses.
- Preserve existing CLI behavior: when the user passes `--password` without a value, prompt for a password locally; when interactive and OAuth fails, prompt the user to try app-password and forward that to the MCP tool.

Assumptions
- We will add a small, backward-compatible change to `mcp.ContentItem` by adding an optional `Metadata json.RawMessage` field. MCP consumers that ignore metadata keep working.
- The Go CLI and tools packages can share prompt_id as a string in the arguments map passed to tools.

Contract (inputs / outputs)
- Tool input shape (login): { handle?: string, password?: string, port?: integer, prompt_id?: string }
- Tool output: ToolResult { content: [ ContentItem ] } where ContentItem may be { type: "text", text: string } or { type: "input_text", text: prompt, metadata: { prompt_id, field, message } }

Edge cases to handle
- password key present but empty -> treat as explicit request to use app-password mode and elicit password if interactive
- non-interactive MCP caller -> return an error rather than an elicitation result
- failing to start callback server or exchange tokens -> where interactive, convert to elicitation offering app-password fallback; where non-interactive return an error

Planned code changes (high level)
1) Update MCP types to support metadata on content items
	- File: `go-server/internal/mcp/types.go`
	- Add Metadata field (json.RawMessage or map[string]interface{}) to `ContentItem` and update JSON tags.

2) Extend LoginTool InputSchema and argument handling
	- File: `go-server/internal/tools/login.go`
	- Add `prompt_id` to the InputSchema properties (optional)
	- When `handle` is missing and caller is interactive (we'll detect interactive by presence of a `prompt_id` param OR when running from CLI adapter which will forward a prompt_id), return a ToolResult containing a ContentItem of type `input_text` with metadata { prompt_id, field: "handle", message: "Enter Bluesky handle (e.g., alice.bsky.social)" }
	- When password parameter key is present but empty, and OAuth fails (or in explicit password flow with empty value), return an input_text prompt for `password` similarly.
	- Ensure returned metadata uses a generated prompt_id if none was supplied (16-char random id, like Rust's new_prompt_id)

3) Wire prompt_id through CLI adapter
	- File: `go-server/internal/cli/login_adapter.go`
	- The CLI adapter should handle elicitation responses from the LoginTool by parsing the metadata (which includes prompt_id generated by the tool) and prompting the user locally on the terminal. The CLI does not generate prompt_ids itself; it only forwards prompt_ids when responding to elicitation.

4) Update CLI interactive retry behavior to align with Rust
	- If OAuth fails in interactive CLI mode, return or surface an elicitation with field "password" asking the user for an app password, rather than simply printing an error. The CLI adapter should then prompt locally for a password and re-call the tool with the password param set.

5) Tests & verification
	- Add unit tests verifying ContentItem JSON includes metadata and that `login` tool returns an elicitation ContentItem when handle is missing and prompt_id present.
	- Run `go build` and relevant unit tests.

Step-by-step tasks (implementation plan)
1. (in-progress) Draft this analysis and plan in this document (done)
2. Update `go-server/internal/mcp/types.go` to add Metadata to `ContentItem` (small, backward compatible)
3. Update `go-server/internal/tools/login.go`:
	- Add prompt_id property to InputSchema
	- Detect presence of password key vs absence to decide app-password vs OAuth
	- Return input_text ContentItem with metadata when missing handle/password in interactive mode
	- Generate prompt_id if not provided
4. Update `go-server/internal/cli/login_adapter.go` to forward/generated prompt_id and to prompt/retry flows like Rust
5. Add unit tests covering serialization and elicitation
6. Build and run tests; fix any issues

Notes and rationale
- Using json.RawMessage for metadata keeps the MCP wire format flexible and avoids early coupling to a strict struct. Consumers may parse metadata as needed.
- This is intentionally a small change limited to internal/mcp and internal/tools/login to avoid broad refactors.
- The Rust implementation's elicitation pattern (prompt_id + field + message) is preserved to keep feature parity with clients that depend on that shape.

Next steps I'll take if you'd like me to implement these changes now
- Apply the minimal type change to `internal/mcp/types.go` (add Metadata)
- Implement elicitation logic in `internal/tools/login.go` and add prompt_id to InputSchema
- Update the CLI adapter to forward prompt_id and handle interactive retries
- Run `go build` and unit tests, and report results

Requirements coverage
- Parity for elicitation behavior: Deferred -> this plan defines the changes required.
- Keep CLI interactive behavior intact: Done (plan preserves existing interactive prompting and augments it for parity).
- Backward compatibility for MCP messages: Done (metadata is optional).

If you want, I can implement the changes now. Which pieces would you like me to start with? (I can begin by updating `types.go` and the login tool.)

## Account Selection: login_hint Parameter Discrepancy

### Current State Analysis

During implementation verification, a critical difference was discovered between Go and Rust OAuth implementations regarding account selection behavior:

**Go Server** (`go-server/internal/auth/oauth.go` lines 83-98):
- **Passes `login_hint` parameter**: The `PushAuthorizationRequest()` method accepts a `loginHint` string and includes it in the PAR (Pushed Authorization Request) when non-empty.
- **Behavior**: Forces OAuth to pre-select the specified account. User must authenticate as the exact handle they provided.
- **Code location**: `internal/tools/login.go` line 522 calls `flow.PushAuthorizationRequest(ctx, handle)`, passing the user's handle as login_hint.

**Rust Server** (`rust-server/src/auth/oauth_atproto.rs` lines 520-535):
- **Does NOT pass `login_hint`**: The `submit_par()` method includes only standard OAuth parameters (response_type, client_id, redirect_uri, code_challenge, etc.) but omits login_hint.
- **Behavior**: Allows OAuth server to present account selection. User can choose ANY account during authorization, regardless of which handle was used for PDS discovery.
- **Code location**: While `start_browser_flow()` accepts the handle and uses it for identity resolution (handle → DID → PDS → Auth Server), the handle is never passed to the authorization server as a hint.

**User Experience Impact**:
| Implementation | OAuth Behavior | User Experience |
|----------------|----------------|-----------------|
| Go (with login_hint) | Pre-selects specified account | "You must log in as alice.bsky.social" |
| Rust (no login_hint) | Allows free selection | "Choose any account you want" |

### Proposal: Optional Handle with Smart Behavior

The discrepancy presents an opportunity for an improved UX design that combines the best of both approaches:

**Design Principle**: 
- When user specifies a handle → enforce it (pass login_hint)
- When user omits handle → allow free selection (no login_hint)

**Two Login Flows**:

1. **Flexible Login (No Handle Specified)**
   ```json
   {"command": "login"}  // or just empty call
   ```
   - Use default BlueSky service (`https://bsky.social`)
   - Discover auth server from default PDS
   - **Do NOT pass login_hint**
   - OAuth presents account selection to user
   - Use case: "Just log me into BlueSky, I'll pick my account"

2. **Directed Login (Handle Specified)**
   ```json
   {"handle": "alice.bsky.social"}
   ```
   - Resolve handle's DID → PDS → Auth Server (supports custom instances)
   - **Pass handle as login_hint**
   - OAuth pre-selects that specific account
   - Use case: "Log me in as this specific account"

**Benefits**:
- ✅ Intuitive: Specificity in request → specificity in behavior
- ✅ Flexible: Quick login for casual users, precise control for power users
- ✅ Custom instance support: Handle resolution still works for non-bsky.social PDSs
- ✅ Backwards compatible: Existing calls with handle behave predictably

### Current Go Implementation vs Proposal

**Go Already Supports This Partially**:
- Go's `PushAuthorizationRequest()` already accepts `loginHint` as a parameter
- It conditionally includes login_hint only when non-empty
- **Gap**: Go currently requires handle parameter, so there's no path to omit login_hint
- **What's needed**: Make handle optional in `LoginTool.Call()` and use default service when handle is absent

**Go Changes Required**:

**Critical Requirement**: All changes must support BOTH MCP and CLI pathways with full test coverage.

1. Update `InputSchema` to mark `handle` as optional (not in required array)
   - **MCP**: Tool schema allows omitting handle parameter
   - **CLI**: Command-line parser allows `autoreply login` without `--handle` flag

2. Modify `performLogin()` in `internal/tools/login.go`:
   - When handle is empty/missing and using OAuth:
     - Use default discovery: `auth.DiscoverServerMetadata(ctx, "https://bsky.social")`
     - Pass empty string to `PushAuthorizationRequest(ctx, "")` → no login_hint
   - When handle is provided:
     - Existing flow: `auth.DiscoverServerMetadataFromHandle(ctx, handle)`
     - Pass handle to `PushAuthorizationRequest(ctx, handle)` → includes login_hint
   - **MCP pathway**: Return appropriate elicitation or proceed with OAuth
   - **CLI pathway**: Handle interactive prompts via CLI adapter

3. Update elicitation logic to differentiate between:
   - Non-interactive mode with missing handle → error (cannot proceed without either handle or user selection)
   - Interactive/MCP mode with missing handle → proceed with OAuth to default service (user selects account in browser)
   - **CLI mode**: Interactive adapter should allow empty handle and proceed with OAuth

4. Update `internal/cli/login_adapter.go`:
   - Handle case where handle is not provided
   - Forward empty handle to tool (don't elicit for it in CLI mode)
   - Allow OAuth flow to proceed for account selection

5. **Mandatory Unit Tests** (`internal/tools/login_test.go`):
   - Test MCP call with no handle → verify OAuth to default service, no login_hint
   - Test MCP call with handle → verify handle resolution, login_hint present
   - Test CLI invocation with no handle → verify OAuth proceeds
   - Test CLI invocation with handle → verify directed login
   - Test error case: non-interactive MCP with no handle and no OAuth support
   - Mock OAuth flow responses to avoid actual network calls

### Current Rust Implementation vs Proposal

**Rust Does NOT Currently Support This**:
- Rust's `start_browser_flow()` requires `handle: &str` parameter (non-optional)
- Rust never passes login_hint (missing feature)
- **Gap**: Cannot omit handle AND missing login_hint parameter entirely

**Rust Changes Required**:

**Critical Requirement**: All changes must support BOTH MCP and CLI pathways with full test coverage.

1. Update `start_browser_flow()` signature in `src/auth/oauth_atproto.rs`:
   ```rust
   pub async fn start_browser_flow(&mut self, handle: Option<&str>) -> Result<BrowserFlowState, AppError>
   ```

2. Modify `submit_par()` to accept optional login_hint:
   ```rust
   async fn submit_par(
       &mut self,
       par_endpoint: &str,
       code_challenge: &str,
       state: &str,
       login_hint: Option<&str>,  // NEW parameter
   ) -> Result<PARResponse, AppError>
   ```

3. Update PAR parameter building:
   ```rust
   let mut params = vec![
       ("response_type", "code"),
       ("client_id", &self.config.client_id),
       ("redirect_uri", &self.config.redirect_uri),
       ("code_challenge", code_challenge),
       ("code_challenge_method", "S256"),
       ("state", state),
       ("scope", &self.config.scope),
   ];
   
   // Add login_hint if provided
   if let Some(hint) = login_hint {
       params.push(("login_hint", hint));
   }
   ```

4. Update `start_browser_flow()` logic:
   ```rust
   let (did, pds_url) = match handle {
       Some(h) => {
           // Existing flow: resolve handle
           let did = self.resolve_handle_to_did(h).await?;
           let pds = self.resolve_did_to_pds(&did).await?;
           (did, pds)
       }
       None => {
           // New flow: use default service
           let pds = "https://bsky.social".to_string();
           // DID will be obtained after token exchange
           ("".to_string(), pds)
       }
   };
   
   let auth_metadata = self.discover_authorization_server(&pds_url).await?;
   
   // ... PKCE generation ...
   
   let par_response = self.submit_par(
       &auth_metadata.pushed_authorization_request_endpoint,
       &code_challenge,
       &state,
       handle,  // Pass handle as login_hint (None if not provided)
   ).await?;
   ```

5. Update `src/auth/login_flow.rs`:
   - Make `handle` field optional in `LoginRequest`/`LoginCommand`
   - Update validation to allow missing handle when using OAuth
   - When handle is None, call `start_browser_flow(None)`
   - **MCP pathway**: Handle None case without elicitation (proceed with OAuth)
   - **CLI pathway**: Allow `autoreply login` without handle argument

6. Update `src/cli.rs`:
   - Make `handle` field `Option<String>` in `LoginCommand` struct
   - Update parser to allow omitting handle
   - Update help text to indicate handle is optional for OAuth

7. Update MCP tool registration in `src/mcp.rs`:
   - Remove `handle` from required fields in JSON schema
   - Add documentation that omitting handle allows account selection

8. **Mandatory Unit Tests** (`src/auth/oauth_atproto.rs` and `src/auth/login_flow.rs`):
   - Test `start_browser_flow(None)` → verify default service, no login_hint
   - Test `start_browser_flow(Some("alice.bsky.social"))` → verify handle resolution, login_hint present
   - Test `submit_par()` with `login_hint: None` → verify PAR params exclude login_hint
   - Test `submit_par()` with `login_hint: Some("handle")` → verify login_hint included
   - **MCP pathway tests** (`src/tests_mcp_adjustments.rs`):
     - Test MCP login call with no handle → verify success
     - Test MCP login call with handle → verify directed login
   - **CLI pathway tests**: Add integration test for `autoreply login` without args
   - Mock HTTP responses to avoid actual network calls

### Implementation Priority

**Recommended Order**:
1. **Rust first** (adds missing login_hint feature + optional handle)
   - More substantial change
   - Brings Rust to parity with Go's login_hint support
   - Enables the flexible/directed login pattern
   - **Must include**: MCP + CLI support + full unit tests

2. **Go second** (adds optional handle support)
   - Smaller change (login_hint already implemented)
   - Just needs to handle missing handle → default service path
   - **Must include**: MCP + CLI support + full unit tests

**Definition of Done (for each server)**:
- ✅ MCP tool accepts optional handle parameter
- ✅ CLI command accepts optional handle argument
- ✅ OAuth flow works with no handle (default service, no login_hint)
- ✅ OAuth flow works with handle (custom discovery, includes login_hint)
- ✅ Unit tests pass (>80% coverage of changed code)
- ✅ Integration tests pass for both MCP and CLI
- ✅ Manual testing confirms account selection behavior
- ✅ Documentation updated (help text, schemas, comments)
- ✅ No regressions in existing login flows (password auth, elicitation)

### Testing Strategy

**Mandatory Test Coverage**: Both MCP and CLI pathways must be fully tested.

#### Go Server Tests (`go-server/internal/tools/login_test.go`):
1. **MCP pathway - No handle provided**: 
   - Verify default service discovery (`https://bsky.social`)
   - Verify PAR request excludes login_hint parameter
   - Verify OAuth flow completes successfully
2. **MCP pathway - Handle provided**: 
   - Verify handle-based discovery
   - Verify PAR request includes login_hint parameter
   - Verify OAuth pre-selects account
3. **CLI pathway - No handle**: 
   - Test `autoreply login` command
   - Verify OAuth proceeds without elicitation
4. **CLI pathway - Handle provided**: 
   - Test `autoreply login --handle alice.bsky.social`
   - Verify directed login flow
5. **Custom instance**: 
   - Test with non-bsky.social handle
   - Verify custom PDS discovery
6. **Error cases**:
   - Non-interactive mode with no handle and app-password → appropriate error

#### Rust Server Tests (`rust-server/src/`):
1. **Unit tests** (`src/auth/oauth_atproto.rs`):
   - Test `start_browser_flow(None)` → default service, no login_hint
   - Test `start_browser_flow(Some("alice.bsky.social"))` → login_hint present
   - Test `submit_par()` parameter inclusion logic
2. **MCP integration tests** (`src/tests_mcp_adjustments.rs`):
   - Test login tool call with `{"handle": null}` or empty object
   - Test login tool call with `{"handle": "alice.bsky.social"}`
   - Verify JSON-RPC responses
3. **CLI integration tests**:
   - Test `autoreply login` (no args)
   - Test `autoreply login --handle alice.bsky.social`
4. **Login flow tests** (`src/auth/login_flow.rs`):
   - Test `LoginRequest` with `handle: None`
   - Test OAuth fallback behavior
5. **Custom instance**: 
   - Test with non-bsky.social handle
   - Verify handle → DID → PDS resolution

#### Common Test Requirements (Both Servers):
- All tests must use mocked HTTP responses (no actual network calls)
- All tests must verify PAR request parameters (presence/absence of login_hint)
- All tests must cover both success and error paths
- Test coverage must exceed 80% for modified code
- Tests must be runnable in CI/CD environment

### Security & Spec Compliance

According to [AT Protocol OAuth spec](https://atproto.com/specs/auth):
- `login_hint` parameter is **optional** and recommended for better UX
- When provided, auth server SHOULD pre-fill/pre-select the specified account
- When omitted, auth server presents normal account selection flow

Both proposed behaviors are compliant and secure. The choice to pass/omit login_hint is a UX decision, not a security consideration.